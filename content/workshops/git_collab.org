#+title: Collaborating through Git
#+subtitle: Example using GitHub as a remote
#+topic: Git
#+slug: git-collab

**** /Abstract/

#+BEGIN_definition
Git is a powerful version control system allowing to record, access, and restore the history of projects.

After setting up remotes on the internet or other network, Git is also a mighty collaboration tool.

In this workshop, we will use the popular online Git repository hosting site GitHub to practice a collaboration workflow typical of many research teams.
#+END_definition

**** /Software requirements/

#+BEGIN_box
*1 - Properly configured Git*

{{<n>}}{{<n>}}You can download Git [[https://gitforwindows.org/][here]]  if you are on Windows and [[https://git-scm.com/downloads][here]] if you use MacOS or Linux.

{{<n>}}{{<n>}}These minimum configurations [[https://westgrid-cli.netlify.app/school/git-03-install/#headline-3][should be set properly]]: \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your user name \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your email address \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your preferred text editor \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- the end of line formatting matching your operating system
{{<2br>}}
*2 - GitHub account*

{{<n>}}{{<n>}}A free [[https://github.com/join?plan=free&source=pricing-card-free][GitHub account]].

{{<n>}}{{<n>}}(Optional) If you don't want to type your password all the time, [[https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh][set SSH for your account]].
#+END_box

**** /Prerequisites/

#+BEGIN_simplebox
*Basic knowledge of Git*:

{{<n>}}{{<n>}}- familiarity with the concept of staging area, \\
{{<n>}}{{<n>}}- experience with staging and committing.
#+END_simplebox

{{<br>}}

Before jumping into our workshop on collaborating with Git using GitHub, let's review key Git concepts.

* Writing a project history with Git

** The three trees of Git

Git has a three-tree architecture:

- The *working directory* or *working tree*:

  An uncompressed version of your files that you can access and edit. You can think of it as a sandbox. This is what is in your project outside the ~.git~ folder and what you usually think of as "your files". {{<2br>}}

- The *staging area* or *index*:

  The snapshot that would be recorded by ~git commit~. {{<2br>}}

- *HEAD*:

  The snapshot of the project at the commit ~HEAD~ is pointing to. {{<2br>}}

Here is an illustration of these three trees:

{{<img src="/img/git/git_img/diagrams/05.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

To display the status of the Git trees, you run:

#+BEGIN_src sh
git status
#+END_src

When you make changes to one of your files, you make changes in the *working directory*. For instance, if you add a new file, your trees will look like this:

{{<img src="/img/git/git_img/diagrams/10.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ will return something like this:

#+BEGIN_src sh
On branch master

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        File

nothing added to commit but untracked files present (use "git add" to track)
#+END_src

You *stage* that file (meaning that you will include the changes of that file in the next commit) with:

#+BEGIN_src sh
git add File
#+END_src

After which, your Git trees look like:

{{<img src="/img/git/git_img/diagrams/11.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ returns something like:

#+BEGIN_src sh
On branch master

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   File
#+END_src

Finally, you make a commit, recording the staged changes to history with:

#+BEGIN_src sh
git commit -m "Added File"
#+END_src

And your trees look like:

{{<img src="/img/git/git_img/diagrams/12.png" title="" width="%" line-height="0rem">}}
{{</img>}}

Now ~git status~ returns:

#+BEGIN_src sh
On branch master
nothing to commit, working tree clean
#+END_src

This means that there are no uncommitted changes in your working tree or the staging area: all your changes have been written to history.

The reason for this 2-stage process is that it allows you to pick and choose the changes that you want to include in a commit. Instead of having a messy bag of all your current changes whenever you write a commit, you can select changes that constitute a coherent unit and commit them together, leaving unrelated changes to be committed later in other commits. This allows for a much clearer history that will be much easier to revisit in the future.

** Commit history

When you write a commit, the proposed snapshot that was in your staging area gets archived inside the ~.git~ repository in a compressed form.

~HEAD~ is a pointer pointing to branches or commits. Branches are also pointers, they point to commits. Finally, commits point to snapshots of your project. After you have made your first commit, this is what your history looks like:

{{<img src="/img/git/git_img/diagrams/13.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

~master~ is the name Git gives to the default branch. ~24duu71~ is the short SHA-1 of your first commit. The SHA-1 is a 40-character checksum hash generated by Git which uniquely identifies each Git object.

If you make new changes in your project, stage all or some of them, and create a new commit, your history will then look like:

{{<img src="/img/git/git_img/diagrams/18.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

Here is what happened when you created that new commit:

- a new snapshot got archived,
- a new commit (with a new unique SHA-1) points to it,
- the ~master~ branch and ~HEAD~ which is pointing to it automatically moved to point to the new commit.

* Branches

** Why use more than just the default master branch?

Branches allow for a convenient workflow:

- you create a new branch for each new development idea,
- you experiment on the branch,
- if you don't like the result, you can simply delete that branch,
- if you like it, you can merge it into the main branch.

What are the advantages of this workflow over a linear one involving only the main branch (automatically called ~master~ by Git)?

- If your changes are very disruptive and break code, you still have a fully functional main branch to go back to if needed while you experiment on your development branch.
- If you want to try an alternative idea, you can go back to the main branch and create a new branch from there to try that alternative approach on it. This allows you to jump back and forth between various approaches to implement an idea.
- If you want to start working on a totally different idea while you haven't finished that first development idea you were working on, you can go back to the main branch and create a new branch from there to work on it so that you don't have messy incomplete work all over the place on the same branch.

** Managing branches

*** Creating branches

#+BEGIN_src sh
git branch <branch-name>
#+END_src

Imagine that you have created 4 commits and that you want to create a branch called "test". You run:

#+BEGIN_src sh
git branch test
#+END_src

And your history now looks like:

{{<img src="/img/git/git_img/diagrams/23.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

*** Checking out an existing branch

Notice that ~HEAD~ still points to your branch ~master~. If you want to work on the branch ~test~, you have to move ~HEAD~ to it. You do this with:

#+BEGIN_src sh
git checkout <branch-name>
#+END_src

Here, we run:

#+BEGIN_src sh
git checkout test
#+END_src

And we get:

{{<img src="/img/git/git_img/diagrams/24.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

*** Better: creating AND checking out a branch in one command

You can create a new branch and switch to it immediately with:

#+BEGIN_src sh
git checkout -b <branch-name>
#+END_src

Why is this better? Because it is easy to create a new branch and forget to switch to it before recording new commits.

*** Deleting branches

You can delete a branch with:

#+BEGIN_src sh
git branch -d <branch-name>
#+END_src

*** Getting information on branches

#+BEGIN_src sh
# list local branches (current branch marked with *)
git branch
git branch -v   # show sha1 and commit message for each head
git branch -vv  # also show upstream branch

# list remote branches
git branch -r

# list all branches
git branch -a
#+END_src

*** Merging branches

Here is a classic workflow with branches:

You just checked out the branch ~test~. Now you make a series of commits on that branch:

{{<img src="/img/git/git_img/diagrams/26.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
You are happy with your changes and you want to merge them back into the main branch (~master~).

First, you checkout master (to merge, you need to be on the branch you want to merge /into/):

#+BEGIN_src sh
git checkout master
#+END_src

{{<img src="/img/git/git_img/diagrams/27.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
Then you merge ~test~ into ~master~:

#+BEGIN_src sh
git merge test
#+END_src

{{<img src="/img/git/git_img/diagrams/28.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
This merge is called a *fast-forward merge*: the ~master~ branch could be fast-forwarded to the branch ~test~.

Now, you can delete the branch ~test~ which has become useless:

#+BEGIN_src sh
git branch -d test
#+END_src

And you have:

{{<img src="/img/git/git_img/diagrams/29.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<2br>}}
Let's consider another common workflow with a branch ~test2~ starting from the same situation (you just created and checked out ~test2~):

{{<img src="/img/git/git_img/diagrams/32.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
You create a number of commits on ~test2~:

{{<img src="/img/git/git_img/diagrams/34.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
Then you checkout ~master~:

{{<img src="/img/git/git_img/diagrams/35.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
and you create commits on ~master~:

{{<img src="/img/git/git_img/diagrams/37.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}
{{<br>}}
To merge ~test2~ into ~master~, you need to be on ~master~, but that's already the case. So you can run:

#+BEGIN_src sh
git merge test2
#+END_src

and you get:

{{<img src="/img/git/git_img/diagrams/38.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

Note that in order to make the merge in this scenario, Git had to create a new commit, called *a merge commit* and that this commit has 2 parents.

Finally, you can now delete the ~test2~ branch with ~git branch -d test2~ to get:

{{<img src="/img/git/git_img/diagrams/39.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

For more information on branches, I recommend to read [[https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell][the chapter on branches]] in the [[https://git-scm.com/book/en/v2][Pro Git book]], an open source project freely available online.

*** Resolving conflicts

If the same section of a file is changed on different branches, Git cannot know which version you would like to keep. The merge gets interrupted until you resolve the conflict.

To resolve the conflict, you can use a merge tool. Run ~git mergetool --tool-help~ to get help setting this up.

Many GUI applications for Git as well as powerful text editors such as Emacs and Vim offer merge tools.

You can also resolve the conflict manually in a text editor:

When a merge gets interrupted due to a conflict, Git tells you which file contains a conflict. Open this file and look for a section that looks like this:

#+BEGIN_src
<<<<<<< HEAD
Version of this section of the file on your checkedout branch
=======
Alternative version of the same section of the file
>>>>>>> alternative version
#+END_src

The ~<<<<<<< HEAD~, ~=======~, and ~>>>>>>>~ are markers added by Git to identify the alternative versions at the location of the conflict.

You have to decide which version you want to keep (or write yet another version), remove the 3 lines with the markers, and remove the line(s) with the version(s) you do not want to keep.

* Remotes

** What are remotes, really?

Remotes are versions of your project that reside outside your project. "Outside" can be anywhere, even on the same machine. Often however, remotes are on a different machine to serve as backup or on a network (possibly the internet) to be accessible by several persons and serve as a syncing hub for collaborations.

A number of online Git repository managers and hosting services have become popular remotes for Git projects. These include [[https://github.com][GitHub]], [[https://gitlab.com][GitLab]], and [[https://bitbucket.org][Bitbucket]].

A project can have several remotes. These remotes are characterized by an address (or a path if they are local) and identified by a name of your choice.

When you clone a repository, the initial repository automatically becomes a remote of your newly created clone and is given the name ~origin~ by Git.

This means that, now that we have cloned a project from GitHub, our new local version already has a remote called ~origin~. You could rename the remote to something else, but it is common practice to keep ~origin~ as the name of the first remote of a project.

** How to see which remotes are associated with my project?

To list your remotes, run:

#+BEGIN_src sh
git remote
#+END_src

To list the remotes with their addresses:

#+BEGIN_src sh
git remote -v
#+END_src

You can verify that your local clone indeed has a remote and that its address matches that of the GitHub project we just cloned.

To get yet more information about a particular remote, you can run:

#+BEGIN_src sh
git remote show <remote-name>
#+END_src

For instance, to inspect your new remote, run:

#+BEGIN_src sh
git remote show origin
#+END_src

** Managing remotes

You add a remote with:

#+BEGIN_src sh
git remote add <remote-name> <remote-url>
#+END_src

You can rename a remote with:

#+BEGIN_src sh
git remote rename <old-name> <new-name>
#+END_src

And you delete a remote with:

#+BEGIN_src sh
git remote rm <remote-name>
#+END_src

You can change the url of the remote with:

#+BEGIN_src sh
git remote set-url <remote-name> <new-url> [<old-url>]
#+END_src

* Contributing to a project

While contributing to a project, you are in one of two scenarios: either you have write access to the project or you do not.

** Read/write access

If you have write access to the project, you can clone the project and directly push changes to it.

*** Cloning a GitHub repository

Cloning a repository creates a local version of a project on your machine.

First, navigate to the directory in which you want to clone the project:

#+BEGIN_src sh
cd /place/where/you/want/to/have/your/project
#+END_src

Then, clone the project.

There are 2 ways to do this. If you have [[https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh][set SSH for your account]], the command is:

#+BEGIN_src sh
git clone git@github.com:<user>/<repo>.git
#+END_src

In our case, this is:

#+BEGIN_src sh
git clone git@github.com:prosoitos/git_workshop_collab.git
#+END_src

If you haven't set SSH for your account, use the HTTPS address and enter your GitHub user name and password when prompted. The general command looks like this:

#+BEGIN_src sh
git clone https://github.com/<user>/<repo>.git
#+END_src

With our project:

#+BEGIN_src sh
git clone https://github.com/prosoitos/git_workshop_collab.git
#+END_src

Note that, if you want to give your copy of the project a different name, you can clone it with either of:

#+BEGIN_src sh
git clone git@github.com:<user>/<repo>.git <name-of-your-copy>
git clone https://github.com/<user>/<repo>.git <name-of-your-copy>
#+END_src

The copy on GitHub is the central copy—the one allowing various team members to work jointly on the same project. But you now have a copy of it (as well as its entire history) on your machine. Your collaborators have their own clones on their own machines.

*** Keeping the repository up to date

Another important thing is to make sure to keep your clone up to date. Your collaborators will make changes to the project on their local clones and push those changes to the GitHub repo. When you cloned the project, you obtained an up-to-date copy. Over time however, that copy will become outdated.

To download new data from the remote (the copy of the project on GitHub), you have 2 options: ~git fetch~ and ~git pull~.

**** Fetching changes

Fetching downloads the data from your remote that you don't already have in your local version of the project.

#+BEGIN_src sh
git fetch <remote-name>
#+END_src

The branches on the remote are now accessible locally as ~<remote-name>/<branch>~. You can inspect them or you can merge them into your local branches.

To fetch from our GitHub remote, we would run:

#+BEGIN_src sh
git fetch origin
#+END_src

**** Pulling changes

Pulling does 2 things: it fetches the data (as we just saw) and it then merges the changes onto your local branches.

#+BEGIN_src sh
git pull <remote-name> <branch>
#+END_src

In our case:

#+BEGIN_src sh
git pull origin master
#+END_src

If your branch is already tracking a remote branch (see below), then you simply need to run:

#+BEGIN_src sh
git pull
#+END_src

Now, how do you push your changes to the remote?

*** Pushing to a remote

#+BEGIN_src sh
git push <remote-name> <branch-name>
#+END_src

If you want to push your ~master~ branch to ~origin~, you would run:

#+BEGIN_src sh
git push origin master
#+END_src

When you cloned the repository, Git also automatically associated your branch ~master~ with the ~master~ branch of ~origin~. So, if you are on the ~master~ branch, you could simply run:

#+BEGIN_src sh
git push
#+END_src

If you want to push another branch to ~origin~, you will have to run the full command:

#+BEGIN_src sh
git push origin <branch-name>
#+END_src

If you want to be able to push the content of that branch by simply running ~git push~ when you are on that branch, you need to set the upstream branch to track your local branch. This can be done by pushing once with the ~-u~ flag:

#+BEGIN_src sh
git push -u origin <branch-name>
#+END_src

From now on, ~git push~ will be enough to push from that branch to ~origin~.

** Read access only

If you do not have write access to the remote, you cannot push to it and you need to submit a pull request (PR).

For this workshop, this is the scenario that we will practice, using [[https://github.com/prosoitos/git_collab][this project]].

*** Fork setup

Here is how to set things up in this scenario:

#+BEGIN_box
1. Fork the project
2. Clone your fork on your machine (remember that this will automatically set the GitHub repo—that is, your fork—as the remote called ~origin~)
3. Add a second remote, this one pointing to the initial project. Usually, that one is called ~upstream~
#+END_box

From here on, you can:

- pull from ~upstream~ (the repo to which you do not have write access and to which you want to contribute). This allows you to keep your fork up-to-date.

- push to and pull from ~origin~ (this is your fork, to which you have read and write access).

*** Pull request

You are now ready to submit pull requests.

Here is the workflow:

#+BEGIN_box
1. Pull from ~upstream~ to make sure that your contributions are made on an up-to-date version of the project
2. Create and checkout a new branch
3. Make and commit your changes on that branch
4. Push that branch to your fork (i.e. ~origin~ — remember that you do not have write access on ~upstream~)
5. Go to the original project GitHub's page and open a pull request from your fork. Note that after you have pushed your branch to origin, GitHub will automatically offer you to do so.
#+END_box

The maintainer of the original project may accept or decline the PR. They may also make comments and ask you to make changes. If so, make new changes and push additional commits to that branch.

Once the PR is merged by the maintainer, you can delete the branch on your fork and pull from ~upstream~ to update your local fork with the recently accepted changes.

[[https://git-scm.com/book/en/v2/GitHub-Contributing-to-a-Project][This chapter of the Pro Git book]] covers this workflow in great details.

* Starting a collaborative project

So far, we have seen how to clone, then contribute to, a project that was already started by someone else.

What if you would like to start a project and allow others to contribute to it through a GitHub remote?

** Initializing a project

First, you need to start a project.

If you are starting a project from scratch, navigate to the location where you would like to create it, then make a new directory for the project:

#+BEGIN_src sh
cd /path/where/you/want/your/project
mkdir <project-name>
#+END_src

If you already have a project, but it is not under version control yet, simply ~cd~ to your project:

#+BEGIN_src sh
cd /path/to/project
#+END_src

Either way, once you hare inside your project, you need to put it under version control by initializing a Git repository:

#+BEGIN_src sh
git init
#+END_src

*Note: do make sure that you are inside the project before running ~git init~. A very common mistake is to run the command outside the project.*

You now have a Git repo. You can verify by running ~ls -a~ from the root of the project and see that you have a ~.git~ directory.

** Adding a remote

Your project does not have any remote: ~git remote~ does not return anything.

If you want to add a remote on GitHub, first you have to go create it.

*** Creating an empty repository on GitHub

Go to https://github.com, login, and go to your home page (https://github.com/<user>).

From there, select the {{<b>}}Repositories{{</b>}} tab, then click the green {{<b>}}New{{</b>}} button.

Enter the name you want for your repo, *without spaces*. It can be the same name you have for your project on your computer (it would be sensible and make things less confusing), but it doesn't have to be.

You can make your repository public or private. Choose the private option if your research contains sensitive data or you do not want to share your project with the world. If you want to develop open source projects, of course, you want to make them public.

Click on the {{<b>}}Code{{</b>}} green drop-down button, select SSH or HTTPS and copy the address of the repo.

*** Adding the new GitHub repo as a remote

Now, go back to your command line, ~cd~ inside your project if you aren't already there and run either of:

#+BEGIN_src sh
git remote add <remote-name> git@github.com:<user>/<repo>.git
git remote add <remote-name> https://github.com/<user>/<repo>.git
#+END_src

(Paste the address you have just copied on GitHub after ~git remote add <remote-name>~).

~<remote-name>~ is only a convenience name that will identify that remote. You can choose any name. But, since Git automatically call the remote ~origin~ when you clone a repo, it is common practice to use ~origin~ as the name for the first remote.

You can now see that your local project now has a remote called ~origin~ and that it has the address of your GitHub repo if you run ~git remote -v~.

If you were working alone on this project and only wanted to have a remote for backup, you would be set.

If you don't want to grant others write access to the project and only accept contributions through pull requests, you are also set.

If you want to grant your collaborators write access to the project however, you need to add them to it.

** Inviting collaborators to a GitHub repo

- Go to your GitHub project page
- Click on the {{<b>}}Settings{{</b>}} tab
- Click on the {{<b>}}Manage access{{</b>}} section on the left-hand side (you will be prompted for your GitHub password)
- Click on the {{<b>}}Invite a collaborator{{</b>}} green button
- Invite your collaborators with one of their GitHub user name, their email address, or their full name

* Comments & questions
