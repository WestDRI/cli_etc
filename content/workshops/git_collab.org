#+title: Collaborating through Git
#+subtitle: Example using GitHub as a remote
#+topic: Git
#+slug: git-collab

**** /Abstract/

#+BEGIN_definition
Git is a powerful version control system allowing to record, access, and restore the history of projects.

After setting up remotes on the internet or other network, Git is also a mighty collaboration tool.

In this workshop, we will use the popular online hosting site GitHub to practice a collaboration workflow typical of research teams.
#+END_definition

**** /Software requirements/

#+BEGIN_box
*1 - Properly configured Git*

{{<n>}}{{<n>}}You can download Git [[https://gitforwindows.org/][here]]  if you are on Windows and [[https://git-scm.com/downloads][here]] if you use MacOS or Linux.

{{<n>}}{{<n>}}These minimum configurations [[https://westgrid-cli.netlify.app/school/git-03-install/#headline-3][should be set properly]]: \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your user name \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your email address \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- your preferred text editor \\
{{<n>}}{{<n>}}{{<n>}}{{<n>}}- the end of line formatting matching your operating system
{{<2br>}}
*2 - GitHub account*

{{<n>}}{{<n>}}A free [[https://github.com/join?plan=free&source=pricing-card-free][GitHub account]].

{{<n>}}{{<n>}}(Optional) If you don't want to type your password all the time, [[https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh][set SSH for your account]].
#+END_box

**** /Prerequisites/

#+BEGIN_simplebox
*Basic knowledge of Git*: \\
{{<n>}}{{<n>}}- familiarity with the concept of staging area, \\
{{<n>}}{{<n>}}- experience (even if limited) with staging and committing.
#+END_simplebox

* Cloning a GitHub repository

When you want to collaborate on a pre-existing project, the first thing you need to do is to clone it to have a local copy on your machine.

First, navigate to the directory in which you want to clone the project:

#+BEGIN_src sh
cd /place/where/you/want/to/have/your/project
#+END_src

Then, clone the project.

For this workshop, we will use [[https://github.com/prosoitos/git_workshop_collab][this project]].

There are 2 ways to do this. If you have [[https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh][set SSH for your account]], the command is:

#+BEGIN_src sh
git clone git@github.com:<user>/<repo>.git
#+END_src

In our case, this is:

#+BEGIN_src sh
git clone git@github.com:prosoitos/git_workshop_collab.git
#+END_src

If you haven't set SSH for your account, use the HTTPS address and enter your GitHub user name and password when prompted. The general command looks like this:

#+BEGIN_src sh
git clone https://github.com/<user>/<repo>.git
#+END_src

With our project:

#+BEGIN_src sh
git clone https://github.com/prosoitos/git_workshop_collab.git
#+END_src

Note that, if you want to give your copy of the project a different name, you can clone it with either of:

#+BEGIN_src sh
git clone git@github.com:<user>/<repo>.git <name-of-your-copy>
git clone https://github.com/<user>/<repo>.git <name-of-your-copy>
#+END_src

The copy on GitHub is the central copyâ€”the one allowing various team members to work jointly on the same project. But you now have a copy of it (as well as its entire history) on your machine. Your collaborators have their own clones on their own machines.

* Remotes

** What are remotes, really?

Remotes are versions of your project that reside outside your project. "Outside" can be anywhere, even on the same machine. Often however, remotes are on a different machine to serve as backup or on a network (possibly the internet) to be accessible by several persons and serve as a syncing hub for collaborations.

A number of online Git repository managers and hosting services have become popular remotes for Git projects. These include [[https://github.com][GitHub]], [[https://gitlab.com][GitLab]], and [[https://bitbucket.org][Bitbucket]].

A project can have several remotes. These remotes are characterized by an address (or a path if they are local) and identified by a name of your choice.

When you clone a repository, the initial repository automatically becomes a remote of your newly created clone and is given the name ~origin~ by Git.

This means that, now that we have cloned a project from GitHub, our new local version already has a remote called ~origin~. You could rename the remote to something else, but it is common practice to keep ~origin~ as the name of the first remote of a project.

** How to see which remotes are associated with my project?

To list your remotes, run:

#+BEGIN_src sh
git remote
#+END_src

To list the remotes with their addresses:

#+BEGIN_src sh
git remote -v
#+END_src

You can verify that your local clone indeed has a remote and that its address matches that of the GitHub project we just cloned.

To get yet more information about a particular remote, you can run:

#+BEGIN_src sh
git remote show <remote-name>
#+END_src

For instance, to inspect your new remote, run:

#+BEGIN_src sh
git remote show origin
#+END_src

** Managing remotes

You can rename a remote with:

#+BEGIN_src sh
git remote rename <old-name> <new-name>
#+END_src

And you delete a remote with:

#+BEGIN_src sh
git remote rm <remote-name>
#+END_src

You can change the url of the remote with:

#+BEGIN_src sh
git remote set-url <remote-name> <new-url> [<old-url>]
#+END_src

* Keeping the repository up to date

Another important thing is to make sure to keep your clone up to date. Your collaborators will make changes to the project on their local clones and push those changes to the GitHub repo. When you cloned the project, you obtained an up-to-date copy. Over time however, that copy will become outdated.

To download new data from the remote (the copy of the project on GitHub), you have 2 options: ~git fetch~ and ~git pull~.

** Fetching changes

Fetching downloads the data from your remote that you don't already have in your local version of the project.

#+BEGIN_src sh
git fetch <remote-name>
#+END_src

The branches on the remote are now accessible locally as ~<remote-name>/<branch>~. You can inspect them or you can merge them into your local branches.

To fetch from our GitHub remote, we would run:

#+BEGIN_src sh
git fetch origin
#+END_src

** Pulling changes

Pulling does 2 things: it fetches the data (as we just saw) and it then merges the changes onto your local branches.

#+BEGIN_src sh
git pull <remote-name> <branch>
#+END_src

In our case:

#+BEGIN_src sh
git pull origin master
#+END_src

If your branch is already tracking a remote branch (see below), then you simply need to run:

#+BEGIN_src sh
git pull
#+END_src

{{<br>}}
Now, how do you actually contribute to the project?

You are in one of two scenarios: either you have write access to the project or you do not. Whatever the case, it is good practice to make use of Git's "killer features": branches.

* Branches

** Why branches?

Branches allow for a convenient workflow:

- you create a new branch for each new development idea
- you experiment on the branch
- if you don't like the result, you can simply delete that branch
- if you like it, you can merge it into the main branch

What are the advantages of this workflow over a linear one involving the main branch only?

- if your changes are very disruptive and break code, you still have a fully functional main branch to go back to if needed while you experiment on your development branch
- if you want to try an alternative idea, you can go back to the main branch and create a new branch from there to try that alternative approach on it. This allows you to jump back and forth between various approaches to implement an idea
- if you want to start working on a totally different idea while you haven't finished that first development idea you were working on, you can go back to the main branch and create a new branch from there to work on it so that you don't have messy incomplete work all over the place on the same branch

** Managing branches

*** Creating branches

#+BEGIN_src sh
git branch <branch-name>
#+END_src

*** Checking out an existing branch

#+BEGIN_src sh
git checkout <branch-name>
#+END_src

*** Better: creating AND checking out a branch in one command

Why better? Because it is easy to create a new branch and forget to switch to it.

#+BEGIN_src sh
git checkout -b <branch-name>
#+END_src

*** Deleting branches

#+BEGIN_src sh
git branch -d <branch-name>
#+END_src

*** Getting information on branches

#+BEGIN_src sh
# list local branches (current branch marked with *)
git branch
git branch -v   # show sha1 and commit message for each head
git branch -vv  # also show upstream branch

# list remote branches
git branch -r

# list all branches
git branch -a
#+END_src

*** Merging branches

- checkout the branch you want to merge /into/
- then merge the branch

For instance, to merge the branch ~devel~ into ~master~:

#+BEGIN_src sh
git checkout master   # of course, this is unnecessary if you were already on master
git merge devel
#+END_src

For more information on branches, I recommend to read [[https://git-scm.com/book/en/v2/Git-Branching-Branches-in-a-Nutshell][the chapter on branches]] in the [[https://git-scm.com/book/en/v2][Pro Git book]], an open source project freely available online.

*** Resolving conflicts

If the same section of a file is changed on different branches, Git cannot know which version you would like to keep. The merge gets interrupted until you resolve the conflict.

To resolve the conflict, you can use a merge tool. Run ~git mergetool --tool-help~ to get help setting this up.

Many GUI applications for Git as well as powerful text editors such as Emacs and Vim offer merge tools.

You can also resolve the conflict manually in a text editor:

When a merge gets interrupted due to a conflict, Git tells you which file contains a conflict. Open this file and look for a section that looks like this:

#+BEGIN_src
<<<<<<< HEAD
Version of this section of the file on your checkedout branch
=======
Alternative version of the same section of the file
>>>>>>> alternative version
#+END_src

The ~<<<<<<< HEAD~, ~=======~, and ~>>>>>>>~ are markers added by Git to identify the alternative versions at the location of the conflict.

You have to decide which version you want to keep (or write yet another version), remove the 3 lines with the markers, and remove the line(s) with the version(s) you do not want to keep.

* Contributing to a project

** Read/write access

If you have write access to the project, you can directly push changes to it:

#+BEGIN_src sh
git push <remote-name> <branch-name>
#+END_src

If you want to push your ~master~ branch to ~origin~, you would run:

#+BEGIN_src sh
git push origin master
#+END_src

When you cloned the repository, Git also automatically associated your branch ~master~ with the ~master~ branch of ~origin~. So, if you are on the ~master~ branch, you could simply run:

#+BEGIN_src sh
git push
#+END_src

If you want to push another branch to ~origin~, you will have to run the full command:

#+BEGIN_src sh
git push origin <branch-name>
#+END_src

If you want to be able to push the content of that branch by simply running ~git push~ when you are on that branch, you need to set the upstream branch to track your local branch. This can be done by pushing once with the ~-u~ flag:

#+BEGIN_src sh
git push -u origin <branch-name>
#+END_src

From now on, ~git push~ will be enough to push from that branch to ~origin~.

