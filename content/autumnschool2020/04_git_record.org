#+title: Recording history
#+description: Zoom
#+colordes: #e86e0a
#+slug: 04_git_record
#+weight: 4

* The three trees of Git

Git has a three-tree architecture:

- The *working directory* or *working tree*:

  An uncompressed version of your files that you can access and edit. You can think of it as a sandbox. This is what is in your project outside the ~.git~ folder and what you usually think of as "your files". {{<2br>}}

- The *staging area* or *index*:

  The snapshot that would be recorded by ~git commit~. {{<2br>}}

- *HEAD*:

  The snapshot of the project at the commit ~HEAD~ is pointing to. {{<2br>}}

Here is an illustration of these three trees:

{{<img src="/img/git/git_img/diagrams/05.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

** Status of the trees

To display the status of the Git trees, you run:

#+BEGIN_src sh
git status
#+END_src

** Making changes to the working tree

When you make changes to one of your files, you make changes in the *working directory*. For instance, if you add a new file, your trees will look like this:

{{<img src="/img/git/git_img/diagrams/10.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ will return something like this:

#+BEGIN_src sh
On branch master

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        File

nothing added to commit but untracked files present (use "git add" to track)
#+END_src

** Staging changes

You /stage/ that file (meaning that you will include the changes of that file in the next commit) with:

#+BEGIN_src sh
git add File
#+END_src

After which, your Git trees look like:

{{<img src="/img/git/git_img/diagrams/11.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ returns something like:

#+BEGIN_src sh
On branch master

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   File
#+END_src

** Committing changes

Finally, you make a /commit/, recording the staged changes to history with:

#+BEGIN_src sh
git commit -m "Added File"
#+END_src

And your trees look like:

{{<img src="/img/git/git_img/diagrams/12.png" title="" width="%" line-height="0rem">}}
{{</img>}}

Now ~git status~ returns:

#+BEGIN_src sh
On branch master
nothing to commit, working tree clean
#+END_src

This means that there are no uncommitted changes in your working tree or the staging area: all your changes have been written to history.

** Why a two-stage process?

The reason for this two-stage process is that it allows you to pick and choose the changes that you want to include in a commit. Instead of having a messy bag of all your current changes whenever you write a commit, you can select changes that constitute a coherent unit and commit them together, leaving unrelated changes to be committed later in other commits. This allows for a much clearer history that will be much easier to revisit in the future.

** Making more commits

Now, let's see what happens when we create a second commit, for instance with changes to your file.

{{<m>}}Make changes to your file:

{{<img src="/img/git/git_img/diagrams/15.png" title="" width="%" line-height="0rem">}}
{{</img>}}

{{<m>}}Stage these changes:

{{<img src="/img/git/git_img/diagrams/16.png" title="" width="%" line-height="0rem">}}
{{</img>}}

{{<m>}}And commit them to history:

{{<img src="/img/git/git_img/diagrams/17.png" title="" width="%" line-height="0rem">}}
{{</img>}}

* Commit history

When you write a commit, the proposed snapshot that was in your staging area gets archived inside the ~.git~ repository in a compressed form.

~HEAD~ is a pointer pointing to branches or commits. Branches are also pointers, they point to commits. Finally, commits point to snapshots of your project. After you have made your first commit, this is what your history looks like:

{{<img src="/img/git/git_img/diagrams/13.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

~master~ is the name Git gives to the default branch. ~24duu71~ is the short SHA-1 of your first commit. The SHA-1 is a 40-character checksum hash generated by Git which uniquely identifies each Git object.

{{<br>}}
If you make new changes in your project, stage all or some of them, and create a new commit, your history will then look like:

{{<img src="/img/git/git_img/diagrams/18.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

Here is what happened when you created that new commit:

- a new snapshot got archived,
- a new commit (with a new unique SHA-1) points to it,
- the ~master~ branch and ~HEAD~ which is pointing to it automatically moved to point to the new commit.

{{<br>}}
After another two commits, your history looks like this:

{{<img src="/img/git/git_img/diagrams/21.png" title="" width="%" line-height="0rem">}}
{{</img>}}

{{<br>}}
Later in this course, since every commit points to a snapshot of your project, I will simplify this graph to:

{{<img src="/img/git/git_img/diagrams/22.png" title="" width="%" line-height="0rem">}}
{{</img>}}

* Comments & questions
