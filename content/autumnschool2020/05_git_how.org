#+title: How Git works
#+description: Reading
#+colordes: #2d5986
#+slug: 05_git_how
#+weight: 5

* How Git saves a project history

Git saves the history of your project as a series of snapshots. Each of these snapshots has a little Git object called a /commit/ pointing to it. Each commit is identified by a unique 40-character checksum hash called a SHA-1 or simply hash.

#+BEGIN_mhexample
Example of a Git SHA-1: 1f5eaef51fcef3f3410dfe8696ff924b10d25b31
#+END_mhexample

The commit contains information about the author of the snapshot, the date and time when it was made, as well as the SHA-1 of its parent(s) commit(s) so that Git can keep track of where it fits in the history relative to other commits.

How do you go from your files to those snapshots?

* The three trees of Git

Git has a three-tree architecture:

- The *working directory* or *working tree*:

  An uncompressed version of your files that you can access and edit. You can think of it as a sandbox. This is what is in your project outside the ~.git~ folder and what you usually think of as "your files". {{<2br>}}

- The *index* or *staging area*:

  The snapshot that would be recorded by ~git commit~. {{<2br>}}

- *HEAD*:

  The snapshot of the project at the commit ~HEAD~ is pointing to. {{<2br>}}

Here is an illustration of these three trees:

{{<img src="/img/git/git_img/diagrams/05.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

** Status of the trees

To display the status of the Git trees, you run:

#+BEGIN_src sh
git status
#+END_src

** Making changes to the working tree

When you make changes to one of your files, you make changes in the *working directory*. For instance, if you add a new file, your trees will look like this:

{{<img src="/img/git/git_img/diagrams/10.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ will return something like this:

#+BEGIN_src sh
On branch master

Untracked files:
  (use "git add <file>..." to include in what will be committed)
        File

nothing added to commit but untracked files present (use "git add" to track)
#+END_src

** Staging changes

You /stage/ that file (meaning that you will include the changes of that file in the next commit) with:

#+BEGIN_src sh
git add File
#+END_src

After which, your Git trees look like:

{{<img src="/img/git/git_img/diagrams/11.png" title="" width="%" line-height="0rem">}}
{{</img>}}

and ~git status~ returns something like:

#+BEGIN_src sh
On branch master

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
        new file:   File
#+END_src

** Committing changes

Finally, you make a /commit/, recording the staged changes to history with:

#+BEGIN_src sh
git commit -m "Added File"
#+END_src

And your trees look like:

{{<img src="/img/git/git_img/diagrams/12.png" title="" width="%" line-height="0rem">}}
{{</img>}}

Now ~git status~ returns:

#+BEGIN_src sh
On branch master
nothing to commit, working tree clean
#+END_src

This means that there are no uncommitted changes in your working tree or the staging area: all your changes have been written to history.

** Why a two-stage process?

The reason for this two-stage process is that it allows you to pick and choose the changes that you want to include in a commit. Instead of having a messy bag of all your current changes whenever you write a commit, you can select changes that constitute a coherent unit and commit them together, leaving unrelated changes to be committed later. This allows for a clearer history that will be easier to revisit in the future.

** Making more commits

Now, let's see what happens when we create a second commit, for instance with changes to your file.

First, you make changes to your file:

{{<img src="/img/git/git_img/diagrams/15.png" title="" width="%" line-height="0rem">}}
{{</img>}}

Then, you stage these changes:

{{<img src="/img/git/git_img/diagrams/16.png" title="" width="%" line-height="0rem">}}
{{</img>}}

Finally, you commit these new changes to history by creating a new snapshot of the project:

{{<img src="/img/git/git_img/diagrams/17.png" title="" width="%" line-height="0rem">}}
{{</img>}}

* Commit history

When you write a commit, the proposed snapshot that was in your staging area gets archived inside the ~.git~ repository in a compressed form and is now part of your project history.

~HEAD~ is a pointer indicating where you currently are in the commit history.

After you have made your first commit, this is what your history looks like:

{{<img src="/img/git/git_img/diagrams/13.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

~HEAD~ points to ~master~ which is the name Git gives to the default branch when you initialize a Git repository. We will talk about branches later. ~24duu71~ is the short SHA-1 of your first commit (the 7 first characters of the SHA-1 for that commit).

{{<br>}}
If you make new changes in your project, stage all or some of them, and create a new commit, your history will then look like:

{{<img src="/img/git/git_img/diagrams/18.png" title="" width="%" line-height="0.5rem">}}
{{</img>}}

Here is what happened when you created that new commit:

- a new snapshot got archived,
- a new commit (with a new unique SHA-1) points to it,
- the ~master~ branch and ~HEAD~ automatically moved to point to the new commit.

{{<br>}}
After another two commits, your history looks like this:

{{<img src="/img/git/git_img/diagrams/21.png" title="" width="%" line-height="0rem">}}
{{</img>}}

{{<br>}}
From now on, since every commit points to a snapshot of your project, I will simplify graphs in this way:

{{<img src="/img/git/git_img/diagrams/22.png" title="" width="%" line-height="0rem">}}
{{</img>}}

* Comments & questions
